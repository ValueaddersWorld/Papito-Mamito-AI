"""Infrastructure & Monitoring for Papito Mamito.

Phase 4 features:
- Health check system (15-minute intervals)
- Alert system for engagement drops/errors
- Human-in-the-loop escalation
- Webhook triggers for real-time responses
- Monthly autonomous review reports
"""

from __future__ import annotations

import asyncio
import hashlib
import hmac
import json
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Callable, Dict, List, Optional
import logging

try:
    import httpx
except ImportError:
    httpx = None


logger = logging.getLogger("papito.monitoring")


class AlertSeverity(str, Enum):
    """Alert severity levels."""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"


class AlertType(str, Enum):
    """Types of alerts."""
    ENGAGEMENT_DROP = "engagement_drop"
    PLATFORM_ERROR = "platform_error"
    API_FAILURE = "api_failure"
    RATE_LIMIT = "rate_limit"
    CONTENT_FLAGGED = "content_flagged"
    HEALTH_CHECK_FAILED = "health_check_failed"
    NEGATIVE_SENTIMENT = "negative_sentiment"


@dataclass
class HealthStatus:
    """Health check status for a component."""
    component: str
    healthy: bool
    last_check: datetime
    message: str = ""
    response_time_ms: float = 0.0
    details: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "component": self.component,
            "healthy": self.healthy,
            "last_check": self.last_check.isoformat(),
            "message": self.message,
            "response_time_ms": self.response_time_ms,
            "details": self.details,
        }


@dataclass
class Alert:
    """An alert generated by the monitoring system."""
    id: str
    alert_type: AlertType
    severity: AlertSeverity
    title: str
    message: str
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    # Context
    platform: Optional[str] = None
    content_id: Optional[str] = None
    interaction_id: Optional[str] = None
    details: Dict[str, Any] = field(default_factory=dict)
    
    # Status
    acknowledged: bool = False
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[datetime] = None
    resolved: bool = False
    resolved_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "alert_type": self.alert_type.value,
            "severity": self.severity.value,
            "title": self.title,
            "message": self.message,
            "created_at": self.created_at.isoformat(),
            "platform": self.platform,
            "content_id": self.content_id,
            "interaction_id": self.interaction_id,
            "details": self.details,
            "acknowledged": self.acknowledged,
            "resolved": self.resolved,
        }


@dataclass
class EscalationRule:
    """Rule for when to escalate to human review."""
    name: str
    condition: str  # Description of condition
    check_fn: Callable[[Dict[str, Any]], bool]
    escalation_channel: str  # "telegram", "discord", "email"
    priority: int = 1  # Higher = more important


class HealthChecker:
    """Performs health checks on system components.
    
    Features:
    - Periodic health checks (configurable interval)
    - Component status tracking
    - Alert generation on failures
    """
    
    # Components to check
    COMPONENTS = [
        "firebase",
        "openai_api",
        "instagram_api",
        "x_api",
        "buffer_api",
    ]
    
    def __init__(
        self,
        check_interval_seconds: int = 900,  # 15 minutes
        alert_callback: Optional[Callable[[Alert], None]] = None,
    ):
        """Initialize health checker.
        
        Args:
            check_interval_seconds: Seconds between checks
            alert_callback: Function to call when alert generated
        """
        self.check_interval = check_interval_seconds
        self.alert_callback = alert_callback
        
        self._status: Dict[str, HealthStatus] = {}
        self._consecutive_failures: Dict[str, int] = {}
        self._running = False
    
    async def check_component(self, component: str) -> HealthStatus:
        """Check health of a specific component.
        
        Args:
            component: Component name to check
            
        Returns:
            HealthStatus
        """
        start = datetime.utcnow()
        
        try:
            if component == "firebase":
                healthy, message = await self._check_firebase()
            elif component == "openai_api":
                healthy, message = await self._check_openai()
            elif component in ["instagram_api", "x_api", "buffer_api"]:
                healthy, message = await self._check_social_api(component)
            else:
                healthy, message = True, "Unknown component"
            
            response_time = (datetime.utcnow() - start).total_seconds() * 1000
            
            status = HealthStatus(
                component=component,
                healthy=healthy,
                last_check=datetime.utcnow(),
                message=message,
                response_time_ms=response_time,
            )
            
        except Exception as e:
            status = HealthStatus(
                component=component,
                healthy=False,
                last_check=datetime.utcnow(),
                message=f"Check failed: {str(e)}",
            )
        
        self._status[component] = status
        
        # Track failures
        if not status.healthy:
            self._consecutive_failures[component] = \
                self._consecutive_failures.get(component, 0) + 1
            
            if self._consecutive_failures[component] >= 3:
                self._generate_alert(component, status)
        else:
            self._consecutive_failures[component] = 0
        
        return status
    
    async def _check_firebase(self) -> tuple[bool, str]:
        """Check Firebase connectivity."""
        try:
            from ..database import get_firebase_client
            db = get_firebase_client()
            # Simple read test
            return True, "Connected"
        except Exception as e:
            return False, str(e)
    
    async def _check_openai(self) -> tuple[bool, str]:
        """Check OpenAI API."""
        try:
            from ..settings import get_settings
            settings = get_settings()
            
            if not settings.openai_api_key:
                return True, "Not configured"
            
            # Would make a lightweight API call here
            return True, "API key configured"
        except Exception as e:
            return False, str(e)
    
    async def _check_social_api(self, component: str) -> tuple[bool, str]:
        """Check social media API connectivity."""
        # In production, would check actual API status
        return True, "Configured"
    
    def _generate_alert(self, component: str, status: HealthStatus) -> None:
        """Generate alert for failed component."""
        alert = Alert(
            id=f"health_{component}_{datetime.utcnow().strftime('%Y%m%d%H%M%S')}",
            alert_type=AlertType.HEALTH_CHECK_FAILED,
            severity=AlertSeverity.ERROR,
            title=f"Health Check Failed: {component}",
            message=status.message,
            details={
                "component": component,
                "consecutive_failures": self._consecutive_failures[component],
            }
        )
        
        if self.alert_callback:
            self.alert_callback(alert)
    
    async def run_all_checks(self) -> Dict[str, HealthStatus]:
        """Run health checks on all components."""
        for component in self.COMPONENTS:
            await self.check_component(component)
        return self._status
    
    def get_status(self) -> Dict[str, Any]:
        """Get current health status summary."""
        healthy_count = sum(1 for s in self._status.values() if s.healthy)
        total = len(self._status)
        
        return {
            "overall": "healthy" if healthy_count == total else "degraded",
            "healthy_components": healthy_count,
            "total_components": total,
            "components": {k: v.to_dict() for k, v in self._status.items()},
            "last_check": datetime.utcnow().isoformat(),
        }


class AlertManager:
    """Manages alerts and notifications.
    
    Features:
    - Alert creation and tracking
    - Multi-channel notifications (Telegram, Discord)
    - Alert acknowledgment and resolution
    """
    
    def __init__(
        self,
        telegram_bot_token: Optional[str] = None,
        telegram_chat_id: Optional[str] = None,
        discord_webhook_url: Optional[str] = None,
    ):
        """Initialize alert manager.
        
        Args:
            telegram_bot_token: Telegram bot token
            telegram_chat_id: Default Telegram chat ID
            discord_webhook_url: Discord webhook URL
        """
        self.telegram_token = telegram_bot_token
        self.telegram_chat_id = telegram_chat_id
        self.discord_webhook = discord_webhook_url
        
        self._alerts: Dict[str, Alert] = {}
        self._alert_history: List[Alert] = []
    
    def create_alert(
        self,
        alert_type: AlertType,
        severity: AlertSeverity,
        title: str,
        message: str,
        **kwargs
    ) -> Alert:
        """Create and store a new alert."""
        alert_id = f"{alert_type.value}_{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
        
        alert = Alert(
            id=alert_id,
            alert_type=alert_type,
            severity=severity,
            title=title,
            message=message,
            **kwargs
        )
        
        self._alerts[alert_id] = alert
        self._alert_history.append(alert)
        
        # Auto-notify for critical alerts
        if severity in (AlertSeverity.ERROR, AlertSeverity.CRITICAL):
            asyncio.create_task(self.notify(alert))
        
        return alert
    
    async def notify(self, alert: Alert) -> Dict[str, bool]:
        """Send alert notifications to configured channels."""
        results = {}
        
        if self.telegram_token and self.telegram_chat_id:
            results["telegram"] = await self._notify_telegram(alert)
        
        if self.discord_webhook:
            results["discord"] = await self._notify_discord(alert)
        
        return results
    
    async def _notify_telegram(self, alert: Alert) -> bool:
        """Send alert to Telegram."""
        if not httpx:
            return False
        
        try:
            emoji = {
                AlertSeverity.INFO: "â„¹ï¸",
                AlertSeverity.WARNING: "âš ï¸",
                AlertSeverity.ERROR: "ðŸš¨",
                AlertSeverity.CRITICAL: "ðŸ”´",
            }
            
            message = (
                f"{emoji.get(alert.severity, 'ðŸ“¢')} *{alert.title}*\n\n"
                f"{alert.message}\n\n"
                f"Type: `{alert.alert_type.value}`\n"
                f"Time: {alert.created_at.strftime('%Y-%m-%d %H:%M UTC')}"
            )
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"https://api.telegram.org/bot{self.telegram_token}/sendMessage",
                    json={
                        "chat_id": self.telegram_chat_id,
                        "text": message,
                        "parse_mode": "Markdown",
                    }
                )
                return response.status_code == 200
                
        except Exception as e:
            logger.error(f"Telegram notification failed: {e}")
            return False
    
    async def _notify_discord(self, alert: Alert) -> bool:
        """Send alert to Discord webhook."""
        if not httpx:
            return False
        
        try:
            color = {
                AlertSeverity.INFO: 0x3498db,
                AlertSeverity.WARNING: 0xf39c12,
                AlertSeverity.ERROR: 0xe74c3c,
                AlertSeverity.CRITICAL: 0x8e44ad,
            }
            
            embed = {
                "title": alert.title,
                "description": alert.message,
                "color": color.get(alert.severity, 0x95a5a6),
                "fields": [
                    {"name": "Type", "value": alert.alert_type.value, "inline": True},
                    {"name": "Severity", "value": alert.severity.value, "inline": True},
                ],
                "timestamp": alert.created_at.isoformat(),
            }
            
            if alert.platform:
                embed["fields"].append({
                    "name": "Platform",
                    "value": alert.platform,
                    "inline": True
                })
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.discord_webhook,
                    json={"embeds": [embed]}
                )
                return response.status_code in (200, 204)
                
        except Exception as e:
            logger.error(f"Discord notification failed: {e}")
            return False
    
    def acknowledge(self, alert_id: str, acknowledged_by: str) -> bool:
        """Acknowledge an alert."""
        if alert_id not in self._alerts:
            return False
        
        alert = self._alerts[alert_id]
        alert.acknowledged = True
        alert.acknowledged_by = acknowledged_by
        alert.acknowledged_at = datetime.utcnow()
        return True
    
    def resolve(self, alert_id: str) -> bool:
        """Mark alert as resolved."""
        if alert_id not in self._alerts:
            return False
        
        alert = self._alerts[alert_id]
        alert.resolved = True
        alert.resolved_at = datetime.utcnow()
        return True
    
    def get_active_alerts(self) -> List[Alert]:
        """Get unresolved alerts."""
        return [a for a in self._alerts.values() if not a.resolved]
    
    def get_alert_summary(self) -> Dict[str, Any]:
        """Get alert statistics."""
        active = self.get_active_alerts()
        
        by_severity = {}
        for severity in AlertSeverity:
            by_severity[severity.value] = sum(
                1 for a in active if a.severity == severity
            )
        
        return {
            "total_active": len(active),
            "by_severity": by_severity,
            "total_historical": len(self._alert_history),
            "oldest_unresolved": min(
                (a.created_at for a in active),
                default=None
            ),
        }


class EscalationManager:
    """Manages human-in-the-loop escalation.
    
    Features:
    - Rule-based escalation triggers
    - Multi-channel escalation
    - Escalation tracking
    """
    
    def __init__(self, alert_manager: AlertManager):
        """Initialize escalation manager."""
        self.alert_manager = alert_manager
        self._rules: List[EscalationRule] = []
        self._pending_escalations: List[Dict[str, Any]] = []
        
        # Add default rules
        self._add_default_rules()
    
    def _add_default_rules(self) -> None:
        """Add default escalation rules."""
        self.add_rule(EscalationRule(
            name="negative_sentiment_vip",
            condition="Very negative sentiment from Super Fan",
            check_fn=lambda ctx: (
                ctx.get("sentiment") == "very_negative" and
                ctx.get("fan_tier") == "super_fan"
            ),
            escalation_channel="telegram",
            priority=5,
        ))
        
        self.add_rule(EscalationRule(
            name="platform_error_critical",
            condition="Critical platform API error",
            check_fn=lambda ctx: (
                ctx.get("error_type") == "api_failure" and
                ctx.get("consecutive_failures", 0) >= 5
            ),
            escalation_channel="discord",
            priority=4,
        ))
        
        self.add_rule(EscalationRule(
            name="engagement_drop_major",
            condition="Engagement dropped more than 50%",
            check_fn=lambda ctx: ctx.get("engagement_change", 0) < -50,
            escalation_channel="telegram",
            priority=3,
        ))
    
    def add_rule(self, rule: EscalationRule) -> None:
        """Add an escalation rule."""
        self._rules.append(rule)
        self._rules.sort(key=lambda r: r.priority, reverse=True)
    
    def check_escalation(self, context: Dict[str, Any]) -> Optional[EscalationRule]:
        """Check if context triggers any escalation rule.
        
        Args:
            context: Context data to check
            
        Returns:
            Triggered rule or None
        """
        for rule in self._rules:
            try:
                if rule.check_fn(context):
                    return rule
            except Exception as e:
                logger.error(f"Error checking rule {rule.name}: {e}")
        
        return None
    
    async def escalate(
        self,
        rule: EscalationRule,
        context: Dict[str, Any],
        custom_message: Optional[str] = None
    ) -> bool:
        """Escalate an issue to human review.
        
        Args:
            rule: The triggered rule
            context: Context data
            custom_message: Optional custom message
            
        Returns:
            True if escalation sent successfully
        """
        message = custom_message or (
            f"ðŸš¨ *Escalation Required*\n\n"
            f"Rule: {rule.name}\n"
            f"Condition: {rule.condition}\n\n"
            f"Context:\n```\n{json.dumps(context, indent=2, default=str)}\n```"
        )
        
        alert = self.alert_manager.create_alert(
            alert_type=AlertType.CONTENT_FLAGGED,
            severity=AlertSeverity.CRITICAL,
            title=f"Escalation: {rule.name}",
            message=message,
            details=context,
        )
        
        self._pending_escalations.append({
            "rule": rule.name,
            "context": context,
            "alert_id": alert.id,
            "created_at": datetime.utcnow(),
        })
        
        result = await self.alert_manager.notify(alert)
        return any(result.values())


class WebhookHandler:
    """Handles incoming and outgoing webhooks.
    
    Features:
    - Webhook signature verification
    - Event routing
    - Response handling
    """
    
    def __init__(self, secret_key: Optional[str] = None):
        """Initialize webhook handler.
        
        Args:
            secret_key: Secret for webhook signature verification
        """
        self.secret_key = secret_key
        self._handlers: Dict[str, List[Callable]] = {}
    
    def register_handler(self, event_type: str, handler: Callable) -> None:
        """Register a handler for an event type."""
        if event_type not in self._handlers:
            self._handlers[event_type] = []
        self._handlers[event_type].append(handler)
    
    def verify_signature(
        self,
        payload: bytes,
        signature: str,
        timestamp: Optional[str] = None
    ) -> bool:
        """Verify webhook signature.
        
        Args:
            payload: Raw request body
            signature: Provided signature
            timestamp: Optional timestamp for replay protection
            
        Returns:
            True if signature is valid
        """
        if not self.secret_key:
            return True  # No verification configured
        
        # Create expected signature
        if timestamp:
            signed_payload = f"{timestamp}.{payload.decode()}"
        else:
            signed_payload = payload.decode()
        
        expected = hmac.new(
            self.secret_key.encode(),
            signed_payload.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(expected, signature)
    
    async def handle_event(
        self,
        event_type: str,
        payload: Dict[str, Any]
    ) -> List[Any]:
        """Handle an incoming webhook event.
        
        Args:
            event_type: Type of event
            payload: Event payload
            
        Returns:
            List of handler results
        """
        handlers = self._handlers.get(event_type, [])
        results = []
        
        for handler in handlers:
            try:
                if asyncio.iscoroutinefunction(handler):
                    result = await handler(payload)
                else:
                    result = handler(payload)
                results.append(result)
            except Exception as e:
                logger.error(f"Webhook handler error: {e}")
                results.append({"error": str(e)})
        
        return results
    
    async def send_webhook(
        self,
        url: str,
        event_type: str,
        payload: Dict[str, Any],
        headers: Optional[Dict[str, str]] = None
    ) -> bool:
        """Send an outgoing webhook.
        
        Args:
            url: Destination URL
            event_type: Event type header
            payload: Payload to send
            headers: Additional headers
            
        Returns:
            True if successful
        """
        if not httpx:
            return False
        
        try:
            default_headers = {
                "Content-Type": "application/json",
                "X-Event-Type": event_type,
            }
            
            if self.secret_key:
                timestamp = str(int(datetime.utcnow().timestamp()))
                body = json.dumps(payload)
                signature = hmac.new(
                    self.secret_key.encode(),
                    f"{timestamp}.{body}".encode(),
                    hashlib.sha256
                ).hexdigest()
                default_headers["X-Signature"] = signature
                default_headers["X-Timestamp"] = timestamp
            
            if headers:
                default_headers.update(headers)
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    url,
                    json=payload,
                    headers=default_headers,
                    timeout=30.0
                )
                return response.status_code < 400
                
        except Exception as e:
            logger.error(f"Webhook send failed: {e}")
            return False
